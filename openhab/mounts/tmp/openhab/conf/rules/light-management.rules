val setLightSwitchableState = [ GenericItem switchable, Number state, Number force | // 0: OFF / FALSE; 1: ON / TRUE
  var command = OFF.toString
  if(state == 0) {
    if(force == 1 || !switchable.state.toString.equals(command.toString)) switchable.sendCommand(command)
    return
  }

  if(SpecialStateManagement.state == 1 && switchable.getGroupNames().contains('gLightManagement_LightSwitchable_IgnoreWhenSleep')) {
    logInfo("light-management.rules", switchable.name + " was ignored during sleep state due to gLightManagement_LightSwitchable_IgnoreWhenSleep group")
    return
  }

  if(switchable.getGroupNames().contains("gLight")){
    command = if(SpecialStateManagement.state == 0) new PercentType((LightManagement_DefaultBrightness.state as DecimalType).intValue).toString else new PercentType((LightManagement_SleepBrightness.state as DecimalType).intValue).toString
  } else if(switchable.getGroupNames().contains("gPower")) {
    command = ON.toString
  } else {
    logWarn("light-management.rules", switchable.name + " has no suitable group to fullfill requirements of a member of gLightManagement_LightSwitchable")
    return
  }

  command = if(force == 1 || switchable.state == OFF || switchable.state == 0) command else switchable.state.toString
  switchable.sendCommand(command)
]

rule "Keep last light activation updated"
when
  Member of gLightManagement_LightSwitchable received update
then
  if(triggeringItem.state == 0 || triggeringItem.state == OFF) {
    return
  }

  val room = transform("REGEX", "s/^([^_]+_[^_]+).*$/$1/g", triggeringItem.name)
	val first = gLightManagement_LastActivation.members.findFirst[f|f.name.startsWith(room)];

  if(first !== null) {
    first.sendCommand(now.toString)
  } else {
    logWarn("light-management.rules", "gLightManagement_LastActivation not found for room " + room);
  }
end

rule "Manage daylight status changes"
when
    Member of gSensor_Luminance changed or
    Item LightManagement_LightState_LuminanceTreshold_Dark changed or
    Item LightManagement_LightState_LuminanceTreshold_Obscured changed
then
  val lightedRooms = gLightManagement_LightSwitchable.members.filter[m|m.state !== NULL && (m.state > 0 || m.state == ON)].map[m|transform("REGEX", "s/^([^_]+_[^_]+).*$/$1/g", m.name)]
  val sensors = gSensor_Luminance.members.filter[i|
    val room = transform("REGEX", "s/^([^_]+_[^_]+).*$/$1/g", i.name)
    return i.state !== NULL && lightedRooms.findFirst[r|r == room] === null
  ].sortBy[state as DecimalType]

  val median = sensors.get(sensors.size / 2).state as Number
  val darkTreshold = LightManagement_LightState_LuminanceTreshold_Dark.state as DecimalType
  val obscuredTreshold = LightManagement_LightState_LuminanceTreshold_Obscured.state as DecimalType
  val state = switch median {
    case median < darkTreshold: 0
    case median < obscuredTreshold: 1
    default: 2
  }
  LightManagement_LightState_LuminanceTreshold.postUpdate(median)

  if(LightManagement_LightState.state != state) {
    LightManagement_LightState.postUpdate(state)
  }
end

rule "Manage lights according to respective modes among special states, nighttime and daytime"
when
  Member of gLightManagement_DarkMode received update or
  Member of gLightManagement_BrightMode received update or
  Member of gLightManagement_ObscuredMode received update or
  Item LightManagement_LightState received update or
  Item SpecialStateManagement received update or
  Item PresenceManagement received update or
  Item LightManagement_DefaultBrightness received update or
  Item LightManagement_SleepBrightness received update
then
  val mode = switch LightManagement_LightState.state as DecimalType  {
    case 0: gLightManagement_DarkMode
    case 1: gLightManagement_ObscuredMode
    case 2: gLightManagement_BrightMode
    default: gLightManagement_BrightMode
  }
  //TODO: Wenn abwesend im Standardmodus => AN
  val switchOnRooms = mode.members.filter[m|m.state == 1 || (m.state == 4 && SpecialStateManagement.state == 0 && PresenceManagement.state == 1) || (m.state == 3 && SpecialStateManagement.state == 0 && PresenceManagement.state != 1) || (m.state == 5 && SpecialStateManagement.state == 0)].map[m|transform("REGEX", "s/^([^_]+_[^_]+).*$/$1/g", m.name)]
  val switchOffRooms = mode.members.filter[m|m.state == 0 || (m.state == 4 && (SpecialStateManagement.state != 0 || PresenceManagement.state != 1)) || (m.state == 3 && (SpecialStateManagement.state != 0 || PresenceManagement.state == 1)) || (m.state == 5 && SpecialStateManagement.state != 0)].map[m|transform("REGEX", "s/^([^_]+_[^_]+).*$/$1/g", m.name)]
  gLightManagement_LightSwitchable.members.forEach[GenericItem item|
    val room = transform("REGEX", "s/^([^_]+_[^_]+).*$/$1/g", item.name)
    if(switchOnRooms.findFirst[r|r == room] !== null) {
      setLightSwitchableState.apply(item, 1, if(SpecialStateManagement.name.equals(triggeringItem.name)) 1 else 0)
    }

    if(switchOffRooms.findFirst[r|r == room] !== null) {
      setLightSwitchableState.apply(item, 0, if(SpecialStateManagement.name.equals(triggeringItem.name)) 1 else 0)
    }
  ]
end

rule "Manage lights on motion"
when
  Member of gPresenceManagement_LastPresence received update
then
	val room = transform("REGEX", "s/^([^_]+_[^_]+).*$/$1/g", triggeringItem.name)
  val mode = switch LightManagement_LightState.state as DecimalType {
    case 0: gLightManagement_DarkMode
    case 1: gLightManagement_ObscuredMode
    case 2: gLightManagement_BrightMode
    default: gLightManagement_BrightMode
  }

  if(mode.members.findFirst[f|f.name.startsWith(room) && f.state == 2] !== null) {
    // Trigger scene instead of lights, if scene is present in room.
    val scenes = gSpecialStateManagement_Scenes.members.filter[i|i.name.startsWith(room)]
    if(scenes.size > 0) {
      scenes.get(0).postUpdate(scenes.get(0).state as Number)
      return
    }

    gLightManagement_LightSwitchable.members.filter[i|i.name.startsWith(room)].forEach[GenericItem i|setLightSwitchableState.apply(i, 1, 0)]
  }
end

rule "Manage lights when come back home"
when
	Item PresenceManagement changed to 1
then
  val welcomeLightMode = switch LightManagement_LightState.state as DecimalType  {
      case 0: LightManagement_WelcomeLight_DarkMode
      case 1: LightManagement_WelcomeLight_ObscuredMode
      case 2: LightManagement_WelcomeLight_BrightMode
      default: LightManagement_WelcomeLight_BrightMode
  }

	if(welcomeLightMode.state == 1) {
    val mode = switch LightManagement_LightState.state as DecimalType  {
      case 0: gLightManagement_DarkMode
      case 1: gLightManagement_ObscuredMode
      case 2: gLightManagement_BrightMode
      default: gLightManagement_BrightMode
    }

    val switchOnRooms = mode.members.filter[m|m.state == 2].map[m|transform("REGEX", "s/^([^_]+_[^_]+).*$/$1/g", m.name)]
    gLightManagement_LightSwitchable.members.forEach[GenericItem item|
      val room = transform("REGEX", "s/^([^_]+_[^_]+).*$/$1/g", item.name)
      if(switchOnRooms.findFirst[r|r == room] !== null) {
        setLightSwitchableState.apply(item, 1, 1)
      }
    ]
  }
end

rule "Manage elapsed lights"
when
  	Time cron "0 * * ? * * *" or
    Item SpecialStateManagement received update or
    Item LightManagement_DefaultDuration received update or
    Item LightManagement_SleepDuration received update
then
  val duration = if (SpecialStateManagement.state == 0) LightManagement_DefaultDuration.state as DecimalType else LightManagement_SleepDuration.state as DecimalType
  val mode = switch LightManagement_LightState.state as DecimalType  {
    case 0: gLightManagement_DarkMode
    case 1: gLightManagement_ObscuredMode
    case 2: gLightManagement_BrightMode
    default: gLightManagement_BrightMode
  }

  val elapsedRooms = gLightManagement_LastActivation.members.filter[m|m.state === NULL || now.minusMinutes(duration.intValue).isAfter((m.state as DateTimeType).zonedDateTime.toInstant().toEpochMilli)].map[m|transform("REGEX", "s/^([^_]+_[^_]+).*$/$1/g", m.name)]
  val switchOffRooms = mode.members.filter[f|f.state == 2].map[m|transform("REGEX", "s/^([^_]+_[^_]+).*$/$1/g", m.name)].filter[r1|elapsedRooms.findFirst[r2|r1 == r2] !== null]
  gLightManagement_LightSwitchable.members.filter[l|(l.state == ON || l.state != 0) && switchOffRooms.findFirst[r|r == transform("REGEX", "s/^([^_]+_[^_]+).*$/$1/g", l.name)] !== null].forEach[f|f.sendCommand(OFF)]
end
